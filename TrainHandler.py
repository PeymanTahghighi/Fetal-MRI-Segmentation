#================================================================================
#================================================================================
from matplotlib.pyplot import axis
import torch
import torch.nn as nn
from tqdm import tqdm
import torch.nn.functional as F
import Config
from Utility import evaluation_metrics
#================================================================================
#================================================================================

#================================================================================
def train_one_epoch(model, loader, critic, optimizer, scaler):
    '''
        General function that trains the 'model' on the images generated by the 
        'loader' by optimizing the parameters using the 'optimizer' and calculating
        the loss using 'critic'
    '''
    model.train();
    with tqdm(loader, unit='batch') as batch_data:
        for mri, seg in batch_data:
            mri,seg = mri.to(Config.DEVICE), seg.to(Config.DEVICE);
            
            output = model(mri);
            loss = critic(output, seg.squeeze(dim=3).long());

            scaler.scale(loss).backward();
            scaler.step(optimizer);
            scaler.update();

            optimizer.zero_grad();

            pass
#================================================================================

#================================================================================
def eval_one_epoch(model, loader, critic, stat_scores):
    '''
        General function that that evaluates a model on the given dataset
        through 'loader paramter'.
        before starting evaluation, we always set model to evaluation mode.
    '''
    model.eval();

    total_loss = 0;

    #used for accumulation
    total_stats = None;
    #counter for number of steps used for divison
    count = 0;

    #used for accumulation of all data, because we want to calculate the micro average
    first = True;
    with torch.no_grad():
        with tqdm(loader, unit='batch') as batch_data:
            for mri, seg in batch_data:

                mri,seg = mri.to(Config.DEVICE), seg.to(Config.DEVICE);

                output = model(mri);
                loss = critic(output, seg.squeeze(dim=3).long());
                output = torch.argmax(torch.softmax(output, dim = 1), dim=1); 

                total_loss += loss.item();

                # #accumulate outputs for final evaluation
                if first is True:
                    total_stats = stat_scores(output.flatten(), seg.flatten().long());
                    first = False;
                else:
                    total_stats += stat_scores(output.flatten(), seg.flatten().long());
                #--------------------------------
                count += 1;

                pass

    
    total_loss /= count;
    
    prec, rec, f1, vs = evaluation_metrics(total_stats);

    return total_loss, prec, rec, f1, vs;
#================================================================================
